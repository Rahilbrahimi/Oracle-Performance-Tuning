create or replace package body pagination_pkg_opt_new_version
 /**
  *DEFAULT VALUES 
  */
---------------------------------------------------
DEFAULT_OFFSET CONSTANT PLS_INTEGER := 0;
DFEAULT_LIMIT CONSTANT PLS_INTEGER := 10;
DEFAULT_LIMIT_MAX CONSTANT PLS_INTEGER := 100;
---------------------------------------------------------------------------------
  /** 
   * validate that the given limit is greater than zero.
   * 
   * @param p_limit Limit value to validate.
   * @raises PAGINATION_LIMIT_ERR if the limit is less than 1.
   */
procedure validate_limit(p_limit in OUT VARCHAR2) is 
 begin  
    IF P_LIMIT IS NULL THEN 
       p_limit := TO_CHAR(DEFAULT_LIMIT);
       RETURN;
    END IF;
    IF NOT REGEXP_LIKE(p_limit,'^\d+$')then 
          error_handeling_pkf_3.raise_error('PAGINATION_LIMIT_ERR');
    END IF;
    IF TO_NUMBER(p_limit) <1 THEN
       ERROR_HANDELING_PKG_3.raise_error('PAGINATION_LIMIT_ERR');
    end if;
END validate_limit;

-------------------------------------------------------------------------
procedure validate_offset(p_offset IN OUT varchar2) is 
  begin 
     if p_offset is not null then 
        p_offset := to_char(DEFAULT_OFFSET);
     RETURN;
  END IF;

  IF NOT REGEXP_LIKE(P_OFFSET,'^\d+$') THEN 
     error_handeling_pkg_3.raise_error('PAGINATION_OFFSET_ERR');
  END IF;

  IF TO_NUMBER(p_OOFSET)< 0 THEN 
     error_handeling_pkg_3.raise_error('PAGINATION_OFFSET_ERR');
  END IF;
END VALIDATE_OFFSET;
---------------------------------------------------------
-- Count items in JSON array
  ---------------------------------------------------------------------------
  FUNCTION fnCount(p_arr IN JSON_ARRAY_T) RETURN PLS_INTEGER IS
  BEGIN
    RETURN p_arr.get_size();
  END fnCount;

  ---------------------------------------------------------------------------
  -- Calculate total pages
  ---------------------------------------------------------------------------
  FUNCTION totalPages(p_total_count IN PLS_INTEGER, p_size IN PLS_INTEGER) RETURN PLS_INTEGER IS
  BEGIN
    IF p_size <= 0 THEN
      RETURN 0;
    ELSE
      RETURN CEIL(p_total_count / p_size);
    END IF;
  END totalPages;

-----------------------
function has_next_page (
  p_offset in pls_integer,
  p_limit in pls_integer,
  p_total in pls_integer
)RETURN BOOLEAN IS 
BEGIN 
   IF P_TOTAL > (P_OFFSET+P_LIMIT) THEN 
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END IF;
END HAS_NEXT_PAGE;
---------------------------------------
--Remove last element from json array
--------------------------------------------------
peocedure remove_last_elemnt(p_data in out nocopy JSON_ARRAY_T)
begin 
  if p_data.get_size()>0 then 
    p_data.remove(p_data.get_Size()-1);
  end if;
end remove_last_elemnt;

-------------------------------------------------------
---Total count
-------------------------------------------------
FUNCTION total_count (p_data in json_array_t) return pls_integer is 
begin  
  return fncount(p_data);
end total_count;
-------------------------------------
---Build invalid link JSON object
----------------------------------------------
FUNCTION link(p_uri in varchar2,p_page in pls_integer,p_Rel in varchar2) return json_object_t is 
  i_json_obj JSON_OBJECT_T :=JSON_OBJECT_T();
  I_URL VARCHAR2(32767);
BEGIN 
  i_uri := REGEXP_REPLACE(p_uri ,'page=[[:digit:]]+','page='||p_page);
  i_json_obj.put('rel',p_rel);
  i_json_obj.put('href',i_uri);
  return i_json_obj;
end link;
----------------------------------------------------------------
--build pagination link array
-----------------------------------------------------------------------
FUNCTION build_pagination_links(
   p_path IN varchar2,
   p_offset in number,
   p_limit in number,
   p_total in number
)return json_array_t is 
  i_json_arr JSON_ARRAY_T := JSON_ARRAY_T();
  I_PAGE     NUMBER := FLOOR(P_OFFSET/P_LIMIT)+1;
  i_total_pages number := CEIL(P_TOTAL/P_LIMIT);
  i_has_more BOOLEAN := has_next_page(P_OFFSET +P_LIMIT,P_TOTAL);
begin 
  i_json_arr.append(link(p_path,I_page,'self'));
    if  i_page> 1 then 
    i_json_arr.append(link(p_path,1,'first'));
    end if;
    IF l_has_more THEN
      l_json_arr.append(link(p_path, l_page + 1, 'next'));
    END IF;

    IF l_page > 1 THEN
      l_json_arr.append(link(p_path, l_page - 1, 'prev'));
    END IF;

    IF l_page != l_total_pages THEN
      l_json_arr.append(link(p_path, l_total_pages, 'last'));
    END IF;

    RETURN l_json_arr;
END build_pagination_links;

-------------------------------------------------------------
-- Main pagination procedure
  ---------------------------------------------------------------------------
  PROCEDURE run(
      p_data        IN CLOB,
      p_total_count IN NUMBER DEFAULT NULL
  ) IS
    l_json_arr JSON_ARRAY_T;
    l_total    PLS_INTEGER;
    l_has_more BOOLEAN;
    l_path     VARCHAR2(32767);
    l_offset   VARCHAR2(10);
    l_limit    VARCHAR2(10);
    l_offset_num NUMBER;
    l_limit_num  NUMBER;
  BEGIN
    -- Parse JSON CLOB to JSON_ARRAY_T
    l_json_arr := JSON_ARRAY_T.parse(p_data);

    -- Read offset and limit directly from query params as VARCHAR2
    l_offset := TO_CHAR(api_util_pkg.get_number_param('offset', DEFAULT_OFFSET));
    l_limit  := TO_CHAR(api_util_pkg.get_number_param('limit', DEFAULT_LIMIT));

    -- Validate offset and limit
    validate_offset(l_offset);
    validate_limit(l_limit);

    l_offset_num := TO_NUMBER(l_offset);
    l_limit_num  := TO_NUMBER(l_limit);

    -- Calculate total items
    IF p_total_count IS NOT NULL THEN
      l_total := p_total_count;
    ELSE
      l_total := fnCount(l_json_arr);
    END IF;

    -- Check for next page
    l_has_more := has_next_page(l_offset_num + l_limit_num, l_total);

    -- Build base path for links
    l_path := api_util_pkg.get_uri_base_path() || api_util_pkg.get_uri_path();

    -- Remove last element if more pages exist
    IF l_has_more THEN
      remove_last_element(l_json_arr);
    END IF;

    -- Build pagination links
    l_json_arr := build_pagination_links(
        p_path   => l_path,
        p_offset => l_offset_num,
        p_limit  => l_limit_num,
        p_total  => l_total
    );

    -- Output result
    DBMS_OUTPUT.PUT_LINE(l_json_arr.to_clob);

  EXCEPTION
    WHEN OTHERS THEN
      error_handling_pkg_3.raise_error('ERR_PAGINATION_RUN');
  END run;

END pagination_pkg_opt_new_version;
/









